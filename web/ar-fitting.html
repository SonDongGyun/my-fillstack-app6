<!doctype html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>안경 AR 가상 피팅 | 눈건강 시력지킴이</title>
<meta name="description" content="카메라 얼굴 인식 기반 3D 안경 AR 가상 피팅" />
<link rel="icon" type="image/svg+xml" href="/static/favicon.svg" />
<link rel="apple-touch-icon" href="/static/davich_logo.png" />
<style>
:root{--b900:#0b3d91;--b700:#1459c2;--b500:#2e7be8;--line:#cfe3ff;--ink:#112a4a;--muted:#45658d}
*{box-sizing:border-box}
body{margin:0;min-height:100vh;font-family:-apple-system,BlinkMacSystemFont,"SF Pro Display","Apple SD Gothic Neo","Noto Sans KR",sans-serif;color:var(--ink);background:radial-gradient(1100px 640px at 10% -10%,#fff 0%,#f3f9ff 45%,#e8f2ff 100%),linear-gradient(180deg,#f8fcff 0%,#eaf4ff 100%);padding:24px}
.app{width:min(1040px,100%);margin:0 auto;border:1px solid var(--line);border-radius:22px;background:#ffffffdb;box-shadow:0 20px 48px #79acee24;padding:20px}
.head{display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap;margin-bottom:14px}
.title{margin:0;color:var(--b900);font-size:1.3rem}
.sub{margin:6px 0 0;color:var(--muted);font-size:.92rem}
.ghost-btn,.primary-btn,.secondary-btn{border:0;border-radius:10px;padding:9px 12px;font-weight:700;cursor:pointer;transition:transform .14s ease,filter .14s ease}
.ghost-btn:hover,.primary-btn:hover,.secondary-btn:hover{transform:translateY(-1px);filter:brightness(1.01)}
.primary-btn{color:#fff;background:linear-gradient(120deg,var(--b700),var(--b500))}
.ghost-btn{border:1px solid #d2e5ff;color:#1d5eb4;background:#f9fcff}
.scroll-cta{will-change:transform,box-shadow;transition:transform .35s cubic-bezier(.22,.61,.36,1),box-shadow .25s ease,border-color .25s ease,background .25s ease;transform-origin:center center;white-space:nowrap}
.scroll-cta.is-docked{position:fixed !important;top:12px;z-index:1300;background:rgba(255,255,255,.9) !important;border-color:#d6e6fb !important;color:#1f539b !important;box-shadow:0 10px 20px rgba(23,79,158,.14) !important}
.cta-placeholder{display:none}
.cta-placeholder.active{display:block}
.layout{display:grid;gap:14px;grid-template-columns:1.2fr .8fr}
.viewer{position:relative;border:1px solid #cfe2ff;border-radius:14px;background:#000;overflow:hidden;aspect-ratio:4/3}
video,canvas{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;transform:scaleX(-1)}
.side{border:1px solid #d8e9ff;border-radius:14px;background:#fbfdff;padding:12px}
.side h2{margin:0 0 10px;color:#164f9f;font-size:1.03rem}
.ctrl{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px}
.select-wrap{margin:10px 0 12px}
.select-label{display:block;margin:0 0 6px;font-size:.84rem;color:#3b5f8c;font-weight:700}
.select{width:100%;border:1px solid #cfe2ff;border-radius:10px;background:#fff;padding:10px 11px;font-size:.92rem;color:#224061}
.note{color:#325780;font-size:.88rem;line-height:1.6}
.status{margin-top:8px;font-size:.88rem;color:#45658d;min-height:1.2rem}
.calib-overlay{position:absolute;inset:0;z-index:8;display:flex;align-items:center;justify-content:center;padding:16px;background:linear-gradient(180deg,#0c2850b3,#0c285088);backdrop-filter:blur(2px)}
.calib-overlay.hidden{display:none}
.calib-card{width:min(360px,92%);border:1px solid #cfe2ff;border-radius:14px;background:#ffffffef;padding:14px 12px;box-shadow:0 12px 24px #00000024;text-align:center}
.calib-title{margin:0;color:#164f9f;font-size:.98rem;font-weight:800}
.calib-desc{margin:6px 0 10px;color:#355985;font-size:.86rem;line-height:1.5}
.calib-gif{width:56px;height:56px;display:block;margin:0 auto 10px}
.calib-bar{height:10px;border-radius:999px;background:#e9f2ff;overflow:hidden;border:1px solid #d2e5ff}
.calib-fill{height:100%;width:0%;background:linear-gradient(120deg,#1459c2,#2e7be8);transition:width .2s ease}
.calib-meta{margin-top:7px;color:#45658d;font-size:.8rem;font-weight:700}
@media (max-width:920px){.layout{grid-template-columns:1fr}.viewer{aspect-ratio:3/4}body{padding:10px}.app{padding:12px}}
</style>
</head>
<body>
<main class="app">
  <section class="head">
    <div>
      <h1 class="title">안경 AR 가상 피팅</h1>
      <p class="sub">초기 얼굴 스캔 후 개인 맞춤 기준으로 3D 피팅을 적용합니다.</p>
      <p class="sub" id="cacheTag" style="font-weight:700;color:#1d5eb4">캐시 태그: ar-fit-cache-20260225-01</p>
    </div>
    <button id="backHomeBtn" class="ghost-btn scroll-cta" data-scroll-cta="game" type="button">운동 메뉴로</button>
    <div class="cta-placeholder" data-cta-placeholder="game"></div>
  </section>

  <section class="layout">
    <div class="viewer">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="arCanvas"></canvas>
      <div id="calibOverlay" class="calib-overlay hidden">
        <div class="calib-card">
          <h3 id="calibTitle" class="calib-title">초기 얼굴 스캔 준비</h3>
          <img class="calib-gif" src="/static/loading-scan.gif" alt="로딩" />
          <p id="calibDesc" class="calib-desc">정면을 유지하면 개인 맞춤 기준을 생성합니다.</p>
          <div class="calib-bar"><div id="calibFill" class="calib-fill"></div></div>
          <div id="calibMeta" class="calib-meta">0%</div>
        </div>
      </div>
    </div>
    <aside class="side">
      <h2>피팅 컨트롤</h2>
      <div class="ctrl">
        <button id="startBtn" class="primary-btn" type="button">카메라 시작</button>
        <button id="stopBtn" class="ghost-btn" type="button">중지</button>
        <button id="recalibrateBtn" class="ghost-btn" type="button">정면 재보정</button>
      </div>
      <div class="ctrl">
        <button id="zoomOutBtn" class="ghost-btn" type="button">화면 축소</button>
        <button id="zoomResetBtn" class="ghost-btn" type="button">배율 1x</button>
        <button id="zoomInBtn" class="ghost-btn" type="button">화면 확대</button>
      </div>
      <div class="select-wrap">
        <label class="select-label" for="modelSelect">안경 모델 선택</label>
        <select id="modelSelect" class="select"></select>
      </div>
      <div class="note" id="pdInfo">정면 점수: 측정 전</div>
      <div id="status" class="status">대기 중</div>
    </aside>
  </section>
</main>

<script src="/static/js/modules/ar-pose-filter.js"></script>
<script>
(()=>{
  const video=document.getElementById("video");
  const canvas=document.getElementById("arCanvas");
  const startBtn=document.getElementById("startBtn");
  const stopBtn=document.getElementById("stopBtn");
  const recalibrateBtn=document.getElementById("recalibrateBtn");
  const zoomOutBtn=document.getElementById("zoomOutBtn");
  const zoomResetBtn=document.getElementById("zoomResetBtn");
  const zoomInBtn=document.getElementById("zoomInBtn");
  const modelSelect=document.getElementById("modelSelect");
  const status=document.getElementById("status");
  const pdInfo=document.getElementById("pdInfo");
  const cacheTagEl=document.getElementById("cacheTag");
  const backHomeBtn=document.getElementById("backHomeBtn");
  const calibOverlay=document.getElementById("calibOverlay");
  const calibTitle=document.getElementById("calibTitle");
  const calibDesc=document.getElementById("calibDesc");
  const calibFill=document.getElementById("calibFill");
  const calibMeta=document.getElementById("calibMeta");

  const MODEL_PATH="/static/models/model_c.glb";
  let CACHE_TAG="deploy-pending";
  const MODEL_BASE={yaw:-Math.PI*0.5,pitch:0,roll:0,offsetY:-0.02,offsetZ:0.02,scale:0.86};
  const FRONTAL={yawDeg:14,pitchDeg:16,rollDeg:11,symmetryMin:0.75,scoreMin:0.5,lockFrames:4};
  const CALIB={samplesNeeded:42,maxNoFaceFrames:45,minFrontalScore:0.5,minSymmetry:0.75};

  const LIB_SOURCES={
    three:["/static/vendor/three.min.js","https://cdn.jsdelivr.net/npm/three/build/three.min.js"],
    gltf:["/static/vendor/GLTFLoader.js","https://cdn.jsdelivr.net/npm/three/examples/js/loaders/GLTFLoader.js"],
    camera:["/static/vendor/camera_utils.js","https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"],
    facemesh:["/static/vendor/face_mesh.js","https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"]
  };

  let faceMesh=null, mpCam=null, pipelineReady=false, running=false, mpAssetBase="/static/vendor/", viewZoom=1;
  let renderer=null, scene=null, cam3d=null, glasses=null, modelBaseQuat=null;
  const smoothState={ready:false,px:0,py:0,pz:0,sx:1,q:null};
  const frontalState={streak:0,locked:false};
  const fitBaseline={ready:false,samples:[],noFaceFrames:0,faceWidth:0,eyeDist:0,templeDist:0,bridgeX:0,bridgeY:0,templeMidX:0,templeMidY:0,frameWorld:0};

  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const median=(arr)=>{ if(!arr||arr.length===0)return 0; const s=[...arr].sort((a,b)=>a-b); const m=Math.floor(s.length*0.5); return s.length%2?s[m]:(s[m-1]+s[m])*0.5; };
  const setStatus=(txt)=>{ status.textContent=txt; };

  function showCalib(title,desc,pct){
    calibOverlay.classList.remove("hidden");
    calibTitle.textContent=title;
    calibDesc.textContent=desc;
    const p=Math.round(clamp(pct||0,0,100));
    calibFill.style.width=`${p}%`;
    calibMeta.textContent=`${p}%`;
  }
  function hideCalib(){ calibOverlay.classList.add("hidden"); }
  function resetFitBaseline(){
    fitBaseline.ready=false; fitBaseline.samples=[]; fitBaseline.noFaceFrames=0;
    fitBaseline.faceWidth=0; fitBaseline.eyeDist=0; fitBaseline.templeDist=0; fitBaseline.bridgeX=0; fitBaseline.bridgeY=0; fitBaseline.templeMidX=0; fitBaseline.templeMidY=0; fitBaseline.frameWorld=0;
  }

  async function resolveMediapipeAssetBase(){
    try{ const r=await fetch("/static/vendor/face_mesh_solution_packed_assets.data",{method:"HEAD",cache:"no-store"}); mpAssetBase=r.ok?"/static/vendor/":"https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/"; }
    catch(_){ mpAssetBase="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/"; }
  }
  function updateCacheUI(){ cacheTagEl.textContent="캐시 태그: "+CACHE_TAG; }
  async function resolveDeployTag(){
    try{
      const res=await fetch(window.location.pathname+"?deploy_check="+Date.now(),{cache:"no-store"});
      const v=res.headers.get("x-vercel-id"); const e=res.headers.get("etag");
      CACHE_TAG=v&&v.trim()?"vercel:"+v.trim():(e&&e.trim()?"etag:"+e.replace(/\"/g,"").trim():"runtime:"+new Date().toISOString());
    }catch(_){ CACHE_TAG="runtime:"+new Date().toISOString(); }
  }

  function loadScript(src){ return new Promise((resolve,reject)=>{ const s=document.createElement("script"); s.src=src; s.async=true; s.onload=()=>resolve(src); s.onerror=()=>reject(new Error(`load failed: ${src}`)); document.head.appendChild(s); }); }
  async function loadFromAny(urls){ let err=null; for(const u of urls){ try{ await loadScript(u); return; }catch(e){ err=e; } } throw err||new Error("script load failed"); }
  async function ensureDeps(){ if(typeof window.THREE==="undefined")await loadFromAny(LIB_SOURCES.three); if(typeof window.THREE.GLTFLoader==="undefined")await loadFromAny(LIB_SOURCES.gltf); if(typeof window.Camera==="undefined")await loadFromAny(LIB_SOURCES.camera); if(typeof window.FaceMesh==="undefined")await loadFromAny(LIB_SOURCES.facemesh); }

  function applyViewZoom(){ const t=`scaleX(-1) scale(${viewZoom.toFixed(2)})`; video.style.transform=t; canvas.style.transform=t; }
  function ndcToWorld(nx,ny){ const hh=Math.tan(THREE.MathUtils.degToRad(cam3d.fov*0.5))*cam3d.position.z; const hw=hh*cam3d.aspect; return new THREE.Vector3((nx-0.5)*2*hw,-(ny-0.5)*2*hh,0); }

  function initRenderer(){
    renderer=new THREE.WebGLRenderer({canvas,alpha:true,antialias:true}); renderer.setPixelRatio(Math.min(window.devicePixelRatio||1,2));
    scene=new THREE.Scene(); cam3d=new THREE.PerspectiveCamera(45,1,0.1,100); cam3d.position.set(0,0,3.2);
    scene.add(new THREE.AmbientLight(0xffffff,1.08)); const key=new THREE.DirectionalLight(0xffffff,0.92); key.position.set(0.2,1.8,2.2); scene.add(key);
    const resize=()=>{ const w=canvas.clientWidth||640, h=canvas.clientHeight||480; renderer.setSize(w,h,false); cam3d.aspect=w/h; cam3d.updateProjectionMatrix(); };
    window.addEventListener("resize",resize); resize();
  }
  function normalizeModelPivot(root){
    root.updateMatrixWorld(true);
    const box=new THREE.Box3().setFromObject(root); const size=new THREE.Vector3(); box.getSize(size); const center=new THREE.Vector3(); box.getCenter(center);
    const pivot=new THREE.Vector3(center.x,box.min.y+(size.y*0.56),center.z); root.position.sub(pivot); root.updateMatrixWorld(true);
    const width=Math.max(size.x,size.z,1e-6); const s=1.0/width; root.scale.multiplyScalar(s); root.userData.normalizedWidth=1.0; root.updateMatrixWorld(true);
  }
  async function loadModelC(){ return new Promise((resolve,reject)=>{ const loader=new THREE.GLTFLoader(); loader.load(MODEL_PATH,(g)=>{ glasses=g.scene; glasses.visible=false; normalizeModelPivot(glasses); modelBaseQuat=new THREE.Quaternion().setFromEuler(new THREE.Euler(MODEL_BASE.pitch,MODEL_BASE.yaw,MODEL_BASE.roll,"YXZ")); scene.add(glasses); resolve(); },undefined,reject); }); }

  function calcPose(pts){
    const eyeL=pts[33], eyeR=pts[263], nose=pts[1]||pts[6]; if(!eyeL||!eyeR||!nose)return null;
    const eyeDx=eyeR.x-eyeL.x, eyeDy=eyeR.y-eyeL.y; const eyeDist=Math.hypot(eyeDx,eyeDy); if(eyeDist<1e-5)return null;
    const eyeMidX=(eyeL.x+eyeR.x)*0.5, eyeMidY=(eyeL.y+eyeR.y)*0.5;
    const faceL=pts[234]||pts[93]||eyeL, faceR=pts[454]||pts[323]||eyeR; const faceWidth=Math.hypot(faceR.x-faceL.x,faceR.y-faceL.y); const templeL=pts[127]||faceL, templeR=pts[356]||faceR; const templeDist=Math.hypot(templeR.x-templeL.x,templeR.y-templeL.y); const templeMidX=(templeL.x+templeR.x)*0.5, templeMidY=(templeL.y+templeR.y)*0.5;
    const bridge=pts[168]||pts[6]||nose;
    const yawDeg=clamp(((nose.x-eyeMidX)/eyeDist)*92,-45,45);
    const pitchDeg=clamp(((nose.y-eyeMidY)/eyeDist)*92,-45,45);
    const rollDeg=clamp(Math.atan2(eyeDy,eyeDx)*180/Math.PI,-45,45);
    const dL=Math.hypot(nose.x-eyeL.x,nose.y-eyeL.y), dR=Math.hypot(nose.x-eyeR.x,nose.y-eyeR.y);
    const symmetry=1-(Math.abs(dL-dR)/(dL+dR+1e-6));
    const yawScore=1-clamp(Math.abs(yawDeg)/FRONTAL.yawDeg,0,1), pitchScore=1-clamp(Math.abs(pitchDeg)/FRONTAL.pitchDeg,0,1), rollScore=1-clamp(Math.abs(rollDeg)/FRONTAL.rollDeg,0,1), symScore=clamp((symmetry-FRONTAL.symmetryMin)/(1-FRONTAL.symmetryMin),0,1);
    const score=(yawScore*0.35)+(pitchScore*0.2)+(rollScore*0.25)+(symScore*0.2);
    return {yawDeg,pitchDeg,rollDeg,symmetry,score,isFrontal:score>=FRONTAL.scoreMin,eyeMidX,eyeMidY,eyeDist,faceWidth,templeDist,templeMidX,templeMidY,bridgeX:bridge.x,bridgeY:bridge.y};
  }

  function collectCalibration(pose){
    if(fitBaseline.ready){ hideCalib(); return; }
    if(!pose){
      fitBaseline.noFaceFrames++;
      const p=clamp((fitBaseline.noFaceFrames/CALIB.maxNoFaceFrames)*100,0,100);
      showCalib("얼굴 인식 대기","정면으로 화면 중앙에 얼굴을 맞춰 주세요",p);
      if(fitBaseline.noFaceFrames>=CALIB.maxNoFaceFrames){ resetFitBaseline(); setStatus("캘리브레이션 실패: 얼굴을 중앙에 두고 다시 시작해 주세요"); }
      return;
    }
    fitBaseline.noFaceFrames=0;
    if(!(pose.score>=CALIB.minFrontalScore&&pose.symmetry>=CALIB.minSymmetry)){
      showCalib("초기 얼굴 스캔 중","정면을 유지해 주세요. 얼굴 각도를 안정화하는 중입니다.",Math.round((fitBaseline.samples.length/CALIB.samplesNeeded)*100));
      return;
    }
    fitBaseline.samples.push({faceWidth:pose.faceWidth,eyeDist:pose.eyeDist,templeDist:pose.templeDist,templeMidX:pose.templeMidX,templeMidY:pose.templeMidY,bridgeX:pose.bridgeX,bridgeY:pose.bridgeY});
    const progress=Math.round((fitBaseline.samples.length/CALIB.samplesNeeded)*100);
    showCalib("초기 얼굴 스캔 중","개인 얼굴 기준점을 생성하고 있습니다.",progress);
    if(fitBaseline.samples.length<CALIB.samplesNeeded)return;
    fitBaseline.faceWidth=median(fitBaseline.samples.map((s)=>s.faceWidth));
    fitBaseline.eyeDist=median(fitBaseline.samples.map((s)=>s.eyeDist));
    fitBaseline.templeDist=median(fitBaseline.samples.map((s)=>s.templeDist)); fitBaseline.templeMidX=median(fitBaseline.samples.map((s)=>s.templeMidX)); fitBaseline.templeMidY=median(fitBaseline.samples.map((s)=>s.templeMidY)); fitBaseline.bridgeX=median(fitBaseline.samples.map((s)=>s.bridgeX)); fitBaseline.bridgeY=median(fitBaseline.samples.map((s)=>s.bridgeY));
    const hh=Math.tan(THREE.MathUtils.degToRad(cam3d.fov*0.5))*cam3d.position.z, hw=hh*cam3d.aspect, worldPerNdc=2*hw;
    fitBaseline.frameWorld=(fitBaseline.templeDist*worldPerNdc*0.98)+(fitBaseline.faceWidth*worldPerNdc*0.16)+(fitBaseline.eyeDist*worldPerNdc*0.10);
    fitBaseline.ready=true;
    showCalib("개인 기준 생성 완료","피팅 적용을 시작합니다.",100);
    setTimeout(hideCalib,350);
    setStatus("개인 기준 생성 완료: 피팅 적용 중");
  }

  function apply3D(pose){
    if(!glasses)return;
    if(!pose||!fitBaseline.ready){ glasses.visible=false; smoothState.ready=false; return; }
    const anchorX=(pose.bridgeX*0.62)+(pose.eyeMidX*0.24)+(pose.templeMidX*0.14);
    const anchorY=(pose.bridgeY*0.64)+(pose.eyeMidY*0.26)+(pose.templeMidY*0.10)-0.01;
    const pos=ndcToWorld(anchorX,anchorY);
    const baseTemple=Math.max(fitBaseline.templeDist||pose.templeDist,1e-5);
    const templeRatio=clamp((pose.templeDist||baseTemple)/baseTemple,0.78,1.26);
    const hh=Math.tan(THREE.MathUtils.degToRad(cam3d.fov*0.5))*cam3d.position.z, hw=hh*cam3d.aspect, worldPerNdc=2*hw;
    const pdWorld=pose.eyeDist*worldPerNdc;
    const desiredFrameWorld=(fitBaseline.frameWorld*templeRatio*0.96)+(pdWorld*0.06);
    const modelNormWidth=(glasses.userData&&glasses.userData.normalizedWidth)||1.0;
    const targetScale=clamp((desiredFrameWorld/modelNormWidth)*MODEL_BASE.scale,0.38,1.25);
    const rollRad=THREE.MathUtils.degToRad(-pose.rollDeg), yawRad=THREE.MathUtils.degToRad(clamp(pose.yawDeg,-12,12))*0.25, pitchRad=THREE.MathUtils.degToRad(clamp(pose.pitchDeg,-12,12))*0.22;
    const qFace=new THREE.Quaternion().setFromEuler(new THREE.Euler(pitchRad,yawRad,rollRad,"YXZ"));
    if(!smoothState.ready){ smoothState.ready=true; smoothState.px=pos.x; smoothState.py=pos.y; smoothState.pz=pos.z; smoothState.sx=targetScale; smoothState.q=qFace.clone(); }
    else { const a=0.22; smoothState.px+= (pos.x-smoothState.px)*a; smoothState.py+=(pos.y-smoothState.py)*a; smoothState.pz+=(pos.z-smoothState.pz)*a; smoothState.sx+=(targetScale-smoothState.sx)*a; smoothState.q.slerp(qFace,a); }
    glasses.visible=true;
    glasses.position.set(smoothState.px,smoothState.py-0.012+MODEL_BASE.offsetY,smoothState.pz+MODEL_BASE.offsetZ);
    glasses.quaternion.copy(smoothState.q); if(modelBaseQuat)glasses.quaternion.multiply(modelBaseQuat); glasses.scale.setScalar(smoothState.sx);
  }

  function updateFrontalState(pose){
    if(!pose){ frontalState.streak=0; frontalState.locked=false; pdInfo.textContent="정면 점수: 측정 전"; return; }
    frontalState.streak=pose.isFrontal?(frontalState.streak+1):Math.max(0,frontalState.streak-1);
    frontalState.locked=frontalState.streak>=FRONTAL.lockFrames;
    pdInfo.textContent=`정면 점수: ${(pose.score*100).toFixed(0)}% / 대칭 ${(pose.symmetry*100).toFixed(0)}%`;
    if(!fitBaseline.ready)setStatus("초기 캘리브레이션 진행 중");
  }

  function resetCalibration(){ frontalState.streak=0; frontalState.locked=false; smoothState.ready=false; resetFitBaseline(); showCalib("초기 얼굴 스캔 준비","정면을 유지하면 개인 맞춤 기준을 생성합니다.",0); if(glasses)glasses.visible=false; setStatus("정면 재보정 중... 정면을 유지해 주세요"); }

  function setupDockedCta(){
    const btn=backHomeBtn, holder=document.querySelector('[data-cta-placeholder="game"]'); if(!btn||!holder)return;
    let triggerY=null, docked=false;
    const ensure=()=>{ if(docked)return; const r=btn.getBoundingClientRect(); if(r.height<=0)return; triggerY=Math.max(0,Math.round(window.scrollY+r.top-12)); };
    const dock=()=>{ if(docked)return; const s=btn.getBoundingClientRect(); const w=Math.min(Math.max(btn.offsetWidth,s.width),Math.max(160,window.innerWidth-20)); const h=Math.max(btn.offsetHeight,s.height); const left=Math.round((window.innerWidth-w)/2); holder.style.height=`${h}px`; holder.classList.add("active"); if(btn.parentElement!==document.body)document.body.appendChild(btn); btn.classList.add("is-docked"); btn.style.width=`${w}px`; btn.style.left=`${left}px`; btn.style.top="12px"; btn.style.position="fixed"; const e=btn.getBoundingClientRect(); btn.style.transition="none"; btn.style.transform=`translate(${(s.left-e.left).toFixed(1)}px, ${(s.top-e.top).toFixed(1)}px)`; requestAnimationFrame(()=>{ btn.style.transition="transform .65s cubic-bezier(.2,.8,.2,1), box-shadow .2s ease"; btn.style.transform="translate(0px, 0px)"; }); docked=true; };
    const undock=()=>{ if(!docked)return; btn.classList.remove("is-docked"); btn.style.width=""; btn.style.left=""; btn.style.top=""; btn.style.position=""; btn.style.transform=""; btn.style.transition=""; const head=document.querySelector(".head"); if(head)head.insertBefore(btn,holder); holder.classList.remove("active"); holder.style.height=""; docked=false; triggerY=null; };
    const update=()=>{ ensure(); if(triggerY===null)return; if(window.scrollY>triggerY)dock(); else undock(); };
    window.addEventListener("scroll",update,{passive:true}); window.addEventListener("resize",()=>{ if(docked)undock(); update(); }); update();
  }

  function ensurePipeline(){
    if(pipelineReady)return;
    faceMesh=new FaceMesh({locateFile:(f)=>`${mpAssetBase}${f}`});
    faceMesh.setOptions({maxNumFaces:1,refineLandmarks:true,minDetectionConfidence:0.35,minTrackingConfidence:0.35});
    faceMesh.onResults((results)=>{
      try{ const pts=results.multiFaceLandmarks&&results.multiFaceLandmarks[0]; const pose=pts?calcPose(pts):null; collectCalibration(pose); updateFrontalState(pose); apply3D(pose); if(renderer&&scene&&cam3d)renderer.render(scene,cam3d); }
      catch(err){ setStatus("추적 처리 오류: 새로고침 후 다시 시도해 주세요"); console.error(err); }
    });
    pipelineReady=true;
  }

  async function start(){
    try{
      setStatus("카메라 시작 중...");
      if(!pipelineReady)ensurePipeline();
      if(typeof Camera==="undefined")throw new Error("Camera unavailable");
      if(!mpCam)mpCam=new Camera(video,{onFrame:async()=>{ if(running)await faceMesh.send({image:video}); },width:960,height:720});
      running=true; resetFitBaseline(); showCalib("초기 얼굴 스캔 준비","정면을 유지하면 개인 맞춤 기준을 생성합니다.",0);
      await mpCam.start(); startBtn.disabled=true; setStatus("실행 중: 초기 캘리브레이션 진행");
    }catch(err){ const msg=String(err?.message||"").toLowerCase(); if(/secure|https/.test(msg))setStatus("카메라 시작 실패: HTTPS 환경에서 실행해 주세요"); else if(/denied|notallowed|permission/.test(msg))setStatus("카메라 권한이 거부되었습니다"); else setStatus("카메라 시작 실패: 라이브러리/권한 확인 필요"); console.error(err); }
  }
  function stop(){ running=false; try{ if(video&&video.srcObject){ video.srcObject.getTracks().forEach((t)=>t.stop()); video.srcObject=null; } if(glasses)glasses.visible=false; hideCalib(); startBtn.disabled=false; setStatus("중지됨"); }catch(_){ } }

  function disableUnusedControls(){ modelSelect.innerHTML=""; const op=document.createElement("option"); op.value=MODEL_PATH; op.textContent="모델 C (고정)"; modelSelect.appendChild(op); modelSelect.disabled=true; }
  function setupZoomControls(){ zoomInBtn.addEventListener("click",()=>{ viewZoom=Math.min(1.8,viewZoom+0.1); applyViewZoom(); }); zoomOutBtn.addEventListener("click",()=>{ viewZoom=Math.max(0.8,viewZoom-0.1); applyViewZoom(); }); zoomResetBtn.addEventListener("click",()=>{ viewZoom=1; applyViewZoom(); }); }

  async function boot(){
    try{
      await ensureDeps(); await resolveMediapipeAssetBase(); initRenderer(); await loadModelC(); applyViewZoom(); setupDockedCta(); setupZoomControls(); disableUnusedControls(); await resolveDeployTag(); updateCacheUI();
      startBtn.addEventListener("click",start); stopBtn.addEventListener("click",stop); recalibrateBtn.addEventListener("click",resetCalibration);
      if(backHomeBtn)backHomeBtn.addEventListener("click",()=>{ window.location.href="/?view=home"; });
      pdInfo.textContent="정면 점수: 측정 전"; setStatus("대기 중: 카메라 시작 후 초기 스캔을 진행합니다");
      if(renderer&&scene&&cam3d)renderer.render(scene,cam3d);
    }catch(err){ setStatus("초기화 실패: 라이브러리/모델 로드를 확인해 주세요"); console.error(err); }
  }

  boot();
})();
</script>
</body>
</html>

