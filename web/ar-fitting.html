<!doctype html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>안경 AR 가상 피팅 | 눈건강 시력지킴이</title>
<meta name="description" content="카메라 얼굴 인식 기반 3D 안경 AR 가상 피팅" />
<link rel="icon" type="image/svg+xml" href="/static/favicon.svg" />
<link rel="apple-touch-icon" href="/static/davich_logo.png" />
<style>
:root{--b900:#0b3d91;--b700:#1459c2;--b500:#2e7be8;--line:#cfe3ff;--ink:#112a4a;--muted:#45658d}
*{box-sizing:border-box}
body{margin:0;min-height:100vh;font-family:-apple-system,BlinkMacSystemFont,"SF Pro Display","Apple SD Gothic Neo","Noto Sans KR",sans-serif;color:var(--ink);background:radial-gradient(1100px 640px at 10% -10%,#fff 0%,#f3f9ff 45%,#e8f2ff 100%),linear-gradient(180deg,#f8fcff 0%,#eaf4ff 100%);padding:24px}
.app{width:min(1040px,100%);margin:0 auto;border:1px solid var(--line);border-radius:22px;background:#ffffffdb;box-shadow:0 20px 48px #79acee24;padding:20px}
.head{display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap;margin-bottom:14px}
.title{margin:0;color:var(--b900);font-size:1.3rem}
.sub{margin:6px 0 0;color:var(--muted);font-size:.92rem}
.ghost-btn,.primary-btn,.secondary-btn{border:0;border-radius:10px;padding:9px 12px;font-weight:700;cursor:pointer;transition:transform .14s ease,filter .14s ease}
.ghost-btn:hover,.primary-btn:hover,.secondary-btn:hover{transform:translateY(-1px);filter:brightness(1.01)}
.primary-btn{color:#fff;background:linear-gradient(120deg,var(--b700),var(--b500))}
.ghost-btn{border:1px solid #d2e5ff;color:#1d5eb4;background:#f9fcff}
.scroll-cta{will-change:transform,box-shadow;transition:transform .35s cubic-bezier(.22,.61,.36,1),box-shadow .25s ease,border-color .25s ease,background .25s ease;transform-origin:center center;white-space:nowrap}
.scroll-cta.is-docked{position:fixed !important;top:12px;z-index:1300;background:rgba(255,255,255,.9) !important;border-color:#d6e6fb !important;color:#1f539b !important;box-shadow:0 10px 20px rgba(23,79,158,.14) !important}
.cta-placeholder{display:none}
.cta-placeholder.active{display:block}
.layout{display:grid;gap:14px;grid-template-columns:1.2fr .8fr}
.viewer{position:relative;border:1px solid #cfe2ff;border-radius:14px;background:#000;overflow:hidden;aspect-ratio:4/3}
video,canvas{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;transform:scaleX(-1)}
.side{border:1px solid #d8e9ff;border-radius:14px;background:#fbfdff;padding:12px}
.side h2{margin:0 0 10px;color:#164f9f;font-size:1.03rem}
.ctrl{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px}
.select-wrap{margin:10px 0 12px}
.select-label{display:block;margin:0 0 6px;font-size:.84rem;color:#3b5f8c;font-weight:700}
.select{width:100%;border:1px solid #cfe2ff;border-radius:10px;background:#fff;padding:10px 11px;font-size:.92rem;color:#224061}
.tune-grid{display:grid;gap:8px;margin-top:6px}
.tune-row{display:grid;grid-template-columns:82px 1fr 52px;gap:8px;align-items:center}
.tune-name{font-size:.8rem;color:#355985;font-weight:700}
.tune-val{font-size:.78rem;color:#355985;text-align:right}
.tune-row input[type="range"]{width:100%}
.note{color:#325780;font-size:.88rem;line-height:1.6}
.status{margin-top:8px;font-size:.88rem;color:#45658d;min-height:1.2rem}
@media (max-width:920px){.layout{grid-template-columns:1fr} .viewer{aspect-ratio:3/4} body{padding:10px}.app{padding:12px}}
</style>
</head>
<body>
<main class="app">
  <section class="head">
    <div>
      <h1 class="title">안경 AR 가상 피팅</h1>
      <p class="sub">모델별 미세 보정을 실시간으로 조절해 정렬을 맞출 수 있습니다.</p>
      <p class="sub" id="cacheTag" style="font-weight:700;color:#1d5eb4">캐시 태그: ar-fit-cache-20260225-01</p>
    </div>
    <button id="backHomeBtn" class="ghost-btn scroll-cta" data-scroll-cta="game" type="button">운동 메뉴로</button>
    <div class="cta-placeholder" data-cta-placeholder="game"></div>
  </section>

  <section class="layout">
    <div class="viewer">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="arCanvas"></canvas>
    </div>
    <aside class="side">
      <h2>피팅 컨트롤</h2>
      <div class="ctrl">
        <button id="startBtn" class="primary-btn" type="button">카메라 시작</button>
        <button id="stopBtn" class="ghost-btn" type="button">중지</button>
        <button id="recalibrateBtn" class="ghost-btn" type="button">정면 재보정</button>
      </div>
      <div class="ctrl">
        <button id="zoomOutBtn" class="ghost-btn" type="button">화면 축소</button>
        <button id="zoomResetBtn" class="ghost-btn" type="button">배율 1x</button>
        <button id="zoomInBtn" class="ghost-btn" type="button">화면 확대</button>
      </div>
      <div class="select-wrap">
        <label class="select-label" for="modelSelect">안경 모델 선택</label>
        <select id="modelSelect" class="select"></select>
      </div>
      <div class="note" id="pdInfo">정면 점수: 측정 전</div>

      <div id="status" class="status">대기 중</div>
    </aside>
  </section>
</main>

<script src="/static/js/modules/ar-pose-filter.js"></script>
<script>
(()=>{
  const video=document.getElementById("video");
  const canvas=document.getElementById("arCanvas");
  const startBtn=document.getElementById("startBtn");
  const stopBtn=document.getElementById("stopBtn");
  const recalibrateBtn=document.getElementById("recalibrateBtn");
  const zoomOutBtn=document.getElementById("zoomOutBtn");
  const zoomResetBtn=document.getElementById("zoomResetBtn");
  const zoomInBtn=document.getElementById("zoomInBtn");
  const modelSelect=document.getElementById("modelSelect");
  const status=document.getElementById("status");
  const pdInfo=document.getElementById("pdInfo");
  const cacheTagEl=document.getElementById("cacheTag");
  const backHomeBtn=document.getElementById("backHomeBtn");

  const MODEL_PATH="/static/models/model_c.glb";
  let CACHE_TAG="deploy-pending";
  const MODEL_BASE={yaw:-Math.PI*0.5,pitch:0,roll:0,offsetY:-0.02,offsetZ:0.02,scale:0.95};

  const LIB_SOURCES={
    three:["/static/vendor/three.min.js","https://cdn.jsdelivr.net/npm/three/build/three.min.js"],
    gltf:["/static/vendor/GLTFLoader.js","https://cdn.jsdelivr.net/npm/three/examples/js/loaders/GLTFLoader.js"],
    camera:["/static/vendor/camera_utils.js","https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"],
    facemesh:["/static/vendor/face_mesh.js","https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"]
  };

  const FRONTAL={yawDeg:12,pitchDeg:14,rollDeg:10,symmetryMin:0.82,scoreMin:0.58,lockFrames:4};

  let faceMesh=null;
  let mpCam=null;
  let pipelineReady=false;
  let running=false;
  let mpAssetBase="/static/vendor/";
  let lastSendErr="";
  let viewZoom=1;

  let renderer=null;
  let scene=null;
  let cam3d=null;
  let glasses=null;
  let modelBaseQuat=null;

  const smoothState={ready:false,px:0,py:0,pz:0,sx:1,sy:1,sz:1,q:null};

  const baseline={ready:false,collecting:true,samples:[],needed:20,xRatio:0,yRatio:0};
  const frontalState={streak:0,locked:false};

  function setStatus(txt){ status.textContent=txt; }
  function clamp(v,min,max){ return Math.max(min,Math.min(max,v)); }

  async function resolveMediapipeAssetBase(){
    const local="/static/vendor/";
    const cdn="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/";
    try{
      const probe=await fetch(local+"face_mesh_solution_packed_assets.data",{method:"HEAD",cache:"no-store"});
      if(probe.ok){
        mpAssetBase=local;
        return;
      }
    }catch(_){ }
    mpAssetBase=cdn;
  }
  function updateCacheUI(){
    if(cacheTagEl)cacheTagEl.textContent="캐시 태그: "+CACHE_TAG;
  }

  async function resolveDeployTag(){
    try{
      const url=window.location.pathname+"?deploy_check="+Date.now();
      const res=await fetch(url,{cache:"no-store"});
      const vercelId=res.headers.get("x-vercel-id");
      const etag=res.headers.get("etag");
      const lastModified=res.headers.get("last-modified");
      if(vercelId&&vercelId.trim()){
        CACHE_TAG="vercel:"+vercelId.trim();
        return;
      }
      if(etag&&etag.trim()){
        CACHE_TAG="etag:"+etag.replace(/\"/g,"").trim();
        return;
      }
      if(lastModified&&lastModified.trim()){
        CACHE_TAG="lm:"+lastModified.trim();
        return;
      }
      CACHE_TAG="runtime:"+new Date().toISOString();
    }catch(_){
      CACHE_TAG="runtime:"+new Date().toISOString();
    }
  }
  function loadScript(src){
    return new Promise((resolve,reject)=>{
      const s=document.createElement("script");
      s.src=src;
      s.async=true;
      s.onload=()=>resolve(src);
      s.onerror=()=>reject(new Error(`load failed: ${src}`));
      document.head.appendChild(s);
    });
  }

  async function loadFromAny(urls){
    let lastErr=null;
    for(const url of urls){
      try{ await loadScript(url); return; }
      catch(err){ lastErr=err; }
    }
    throw lastErr||new Error("script load failed");
  }

  async function ensureDeps(){
    if(typeof window.THREE==="undefined")await loadFromAny(LIB_SOURCES.three);
    if(typeof window.THREE.GLTFLoader==="undefined")await loadFromAny(LIB_SOURCES.gltf);
    if(typeof window.Camera==="undefined")await loadFromAny(LIB_SOURCES.camera);
    if(typeof window.FaceMesh==="undefined")await loadFromAny(LIB_SOURCES.facemesh);
    if(typeof window.THREE==="undefined"||typeof window.FaceMesh==="undefined"||typeof window.Camera==="undefined")throw new Error("deps load failed");
  }

  function applyViewZoom(){
    const t=`scaleX(-1) scale(${viewZoom.toFixed(2)})`;
    video.style.transform=t;
    canvas.style.transform=t;
  }

  function median(arr){
    if(!arr||arr.length===0)return 0;
    const sorted=[...arr].sort((a,b)=>a-b);
    const m=Math.floor(sorted.length*0.5);
    return sorted.length%2?sorted[m]:(sorted[m-1]+sorted[m])*0.5;
  }

  function initRenderer(){
    renderer=new THREE.WebGLRenderer({canvas,alpha:true,antialias:true});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio||1,2));
    scene=new THREE.Scene();
    cam3d=new THREE.PerspectiveCamera(45,1,0.1,100);
    cam3d.position.set(0,0,3.2);

    scene.add(new THREE.AmbientLight(0xffffff,1.08));
    const keyLight=new THREE.DirectionalLight(0xffffff,0.92);
    keyLight.position.set(0.2,1.8,2.2);
    scene.add(keyLight);

    const resize=()=>{
      const w=canvas.clientWidth||640;
      const h=canvas.clientHeight||480;
      renderer.setSize(w,h,false);
      cam3d.aspect=w/h;
      cam3d.updateProjectionMatrix();
    };
    window.addEventListener("resize",resize);
    resize();
  }

  function ndcToWorld(nx,ny){
    const halfH=Math.tan(THREE.MathUtils.degToRad(cam3d.fov*0.5))*cam3d.position.z;
    const halfW=halfH*cam3d.aspect;
    return new THREE.Vector3((nx-0.5)*2*halfW,-(ny-0.5)*2*halfH,0);
  }

  function normalizeModelPivot(root){
    if(!root||!window.THREE)return;
    root.updateMatrixWorld(true);
    const box=new THREE.Box3().setFromObject(root);
    const size=new THREE.Vector3();
    box.getSize(size);
    const center=new THREE.Vector3();
    box.getCenter(center);

    const pivot=new THREE.Vector3(
      center.x,
      box.min.y+(size.y*0.56),
      center.z
    );

    root.position.sub(pivot);
    root.updateMatrixWorld(true);

    const width=Math.max(size.x,size.z,1e-6);
    const targetWidth=1.08;
    const s=targetWidth/width;
    root.scale.multiplyScalar(s);
    root.updateMatrixWorld(true);
  }
  async function loadModelC(){
    return new Promise((resolve,reject)=>{
      const loader=new THREE.GLTFLoader();
      loader.load(MODEL_PATH,(gltf)=>{
        glasses=gltf.scene;
        glasses.visible=false;
        normalizeModelPivot(glasses);
        if(!modelBaseQuat)modelBaseQuat=new THREE.Quaternion();
        modelBaseQuat.setFromEuler(new THREE.Euler(MODEL_BASE.pitch,MODEL_BASE.yaw,MODEL_BASE.roll,"YXZ"));
        scene.add(glasses);
        resolve();
      },undefined,(err)=>reject(err));
    });
  }

  function calcPose(pts){
    const eyeL=pts[33],eyeR=pts[263],nose=pts[1]||pts[6];
    if(!eyeL||!eyeR||!nose)return null;

    const eyeDx=eyeR.x-eyeL.x;
    const eyeDy=eyeR.y-eyeL.y;
    const eyeDist=Math.hypot(eyeDx,eyeDy);
    if(eyeDist<1e-5)return null;

    const eyeMidX=(eyeL.x+eyeR.x)*0.5;
    const eyeMidY=(eyeL.y+eyeR.y)*0.5;

    const xRatio=(nose.x-eyeMidX)/eyeDist;
    const yRatio=(nose.y-eyeMidY)/eyeDist;
    const noseX=nose.x;
    const noseY=nose.y;

    if(baseline.collecting){
      baseline.samples.push({xRatio,yRatio});
      if(baseline.samples.length>=baseline.needed){
        baseline.xRatio=median(baseline.samples.map((s)=>s.xRatio));
        baseline.yRatio=median(baseline.samples.map((s)=>s.yRatio));
        baseline.ready=true;
        baseline.collecting=false;
        setStatus("기준 캘리브레이션 완료");
      }
    }

    const baseX=baseline.ready?baseline.xRatio:xRatio;
    const baseY=baseline.ready?baseline.yRatio:yRatio;

    const yawDeg=clamp((xRatio-baseX)*120,-45,45);
    const pitchDeg=clamp((yRatio-baseY)*120,-45,45);
    const rollDeg=clamp(Math.atan2(eyeDy,eyeDx)*180/Math.PI,-45,45);

    const dL=Math.hypot(nose.x-eyeL.x,nose.y-eyeL.y);
    const dR=Math.hypot(nose.x-eyeR.x,nose.y-eyeR.y);
    const symmetry=1-(Math.abs(dL-dR)/(dL+dR+1e-6));

    const yawScore=1-clamp(Math.abs(yawDeg)/FRONTAL.yawDeg,0,1);
    const pitchScore=1-clamp(Math.abs(pitchDeg)/FRONTAL.pitchDeg,0,1);
    const rollScore=1-clamp(Math.abs(rollDeg)/FRONTAL.rollDeg,0,1);
    const symScore=clamp((symmetry-FRONTAL.symmetryMin)/(1-FRONTAL.symmetryMin),0,1);
    const score=(yawScore*0.35)+(pitchScore*0.20)+(rollScore*0.25)+(symScore*0.20);

    const isFrontal=(Math.abs(yawDeg)<=FRONTAL.yawDeg)&&
      (Math.abs(pitchDeg)<=FRONTAL.pitchDeg)&&
      (Math.abs(rollDeg)<=FRONTAL.rollDeg)&&
      (symmetry>=FRONTAL.symmetryMin)&&
      (score>=FRONTAL.scoreMin);

    return {yawDeg,pitchDeg,rollDeg,symmetry,score,isFrontal,eyeL,eyeR,eyeMidX,eyeMidY,eyeDist,noseX,noseY};
  }

  function apply3D(pose){
    if(!glasses)return;
    const canShow=!!pose;
    if(!canShow){
      glasses.visible=false;
      smoothState.ready=false;
      return;
    }

    const anchorX=(pose.noseX*0.62)+(pose.eyeMidX*0.38);
    const anchorY=(pose.noseY*0.62)+(pose.eyeMidY*0.38)+0.01;
    const pos=ndcToWorld(anchorX,anchorY);
    const eyeDistNdc=pose.eyeDist;
    const targetScale=clamp(eyeDistNdc*6.0,0.45,2.2)*MODEL_BASE.scale;

    const rollRad=THREE.MathUtils.degToRad(-pose.rollDeg);
    const yawRad=THREE.MathUtils.degToRad(clamp(pose.yawDeg,-12,12))*0.25;
    const pitchRad=THREE.MathUtils.degToRad(clamp(pose.pitchDeg,-12,12))*0.22;

    const qFace=new THREE.Quaternion().setFromEuler(new THREE.Euler(pitchRad,yawRad,rollRad,"YXZ"));

    if(!smoothState.ready){
      smoothState.ready=true;
      smoothState.px=pos.x;
      smoothState.py=pos.y;
      smoothState.pz=pos.z;
      smoothState.sx=targetScale;
      smoothState.q=qFace.clone();
    }else{
      const a=0.28;
      smoothState.px=smoothState.px+(pos.x-smoothState.px)*a;
      smoothState.py=smoothState.py+(pos.y-smoothState.py)*a;
      smoothState.pz=smoothState.pz+(pos.z-smoothState.pz)*a;
      smoothState.sx=smoothState.sx+(targetScale-smoothState.sx)*a;
      smoothState.q.slerp(qFace,a);
    }

    glasses.visible=true;
    glasses.position.set(smoothState.px,smoothState.py-0.045+MODEL_BASE.offsetY,smoothState.pz+MODEL_BASE.offsetZ);
    glasses.quaternion.copy(smoothState.q);
    if(modelBaseQuat)glasses.quaternion.multiply(modelBaseQuat);
    glasses.scale.setScalar(smoothState.sx);
  }

  function updateFrontalState(pose){
    if(!pose){
      frontalState.streak=0;
      frontalState.locked=false;
      setStatus("얼굴 미검출: 얼굴을 화면 중앙에 맞춰 주세요");
      updateCacheUI();
      pdInfo.textContent="정면 점수: 측정 전";
      return;
    }

    frontalState.streak=pose.isFrontal?(frontalState.streak+1):Math.max(0,frontalState.streak-1);
    frontalState.locked=frontalState.streak>=FRONTAL.lockFrames;

    const lockTxt=frontalState.locked?"정면 확정(모델 표시)":"정면 대기";
    setStatus(`${lockTxt} | yaw ${pose.yawDeg.toFixed(1)} pitch ${pose.pitchDeg.toFixed(1)} roll ${pose.rollDeg.toFixed(1)}`);
    pdInfo.textContent=`정면 점수: ${(pose.score*100).toFixed(0)}% / 대칭 ${(pose.symmetry*100).toFixed(0)}%`;
  }

  function resetCalibration(){
    baseline.ready=false;
    baseline.collecting=true;
    baseline.samples=[];
    frontalState.streak=0;
    frontalState.locked=false;
    smoothState.ready=false;
    if(glasses)glasses.visible=false;
    setStatus("정면 재보정 중... 정면을 유지해 주세요");
  }

  function ensurePipeline(){
    if(pipelineReady)return;

    faceMesh=new FaceMesh({locateFile:(f)=>`${mpAssetBase}${f}`});
    faceMesh.setOptions({maxNumFaces:1,refineLandmarks:true,minDetectionConfidence:0.35,minTrackingConfidence:0.35});
    faceMesh.onResults((results)=>{
      try{
        const pts=results.multiFaceLandmarks&&results.multiFaceLandmarks[0];
        const pose=pts?calcPose(pts):null;
        updateFrontalState(pose);
        apply3D(pose);
        if(renderer&&scene&&cam3d)renderer.render(scene,cam3d);
      }catch(err){
        setStatus("추적 처리 오류: 새로고침 후 다시 시도해 주세요");
        console.error(err);
      }
    });

    pipelineReady=true;
  }

  async function start(){
    try{
      setStatus("카메라 시작 중...");
      if(!pipelineReady)ensurePipeline();
      if(typeof Camera==="undefined")throw new Error("Camera unavailable");

      if(!mpCam){
        mpCam=new Camera(video,{onFrame:async()=>{ if(running)await faceMesh.send({image:video}); },width:960,height:720});
      }

      running=true;
      await mpCam.start();
      startBtn.disabled=true;
      setStatus("실행 중: 모델 C 고정");
    }catch(err){
      const msg=String(err?.message||"").toLowerCase();
      if(/secure|https/.test(msg))setStatus("카메라 시작 실패: HTTPS 환경에서 실행해 주세요");
      else if(/denied|notallowed|permission/.test(msg))setStatus("카메라 권한이 거부되었습니다");
      else setStatus("카메라 시작 실패: 라이브러리/권한 확인 필요");
      console.error(err);
    }
  }

  function stop(){
    running=false;
    try{
      if(video&&video.srcObject){
        video.srcObject.getTracks().forEach((t)=>t.stop());
        video.srcObject=null;
      }
      if(glasses)glasses.visible=false;
      startBtn.disabled=false;
      setStatus("중지됨");
    }catch(_){ }
  }

  function disableUnusedControls(){
    modelSelect.innerHTML="";
    const op=document.createElement("option");
    op.value=MODEL_PATH;
    op.textContent="모델 C (고정)";
    modelSelect.appendChild(op);
    modelSelect.disabled=true;
  }

  function setupZoomControls(){
    zoomInBtn.addEventListener("click",()=>{ viewZoom=Math.min(1.8,viewZoom+0.1); applyViewZoom(); });
    zoomOutBtn.addEventListener("click",()=>{ viewZoom=Math.max(0.8,viewZoom-0.1); applyViewZoom(); });
    zoomResetBtn.addEventListener("click",()=>{ viewZoom=1; applyViewZoom(); });
  }

  async function boot(){
    try{
      await ensureDeps();
      await resolveMediapipeAssetBase();
      initRenderer();
      await loadModelC();
      applyViewZoom();
      setupZoomControls();
      disableUnusedControls();

      await resolveDeployTag();
      updateCacheUI();

      startBtn.addEventListener("click",start);
      stopBtn.addEventListener("click",stop);
      recalibrateBtn.addEventListener("click",resetCalibration);
      if(backHomeBtn)backHomeBtn.addEventListener("click",()=>{ window.location.href="/?view=home"; });

      updateCacheUI();
      pdInfo.textContent="정면 점수: 측정 전";
      setStatus("대기 중: 모델 C는 정면 확정 시에만 표시됩니다");
      if(renderer&&scene&&cam3d)renderer.render(scene,cam3d);
    }catch(err){
      setStatus("초기화 실패: 라이브러리/모델 로드를 확인해 주세요");
      console.error(err);
    }
  }

  boot();
})();
</script>
<script>
(()=>{
  const btn=document.getElementById("backHomeBtn");
  const holder=document.querySelector("[data-cta-placeholder=\"game\"]");
  if(!btn||!holder)return;
  let triggerY=null;
  let docked=false;

  function ensureTrigger(){
    if(docked)return;
    const rect=btn.getBoundingClientRect();
    if(rect.height<=0)return;
    triggerY=Math.max(0,Math.round(window.scrollY+rect.top-12));
  }

  function dock(){
    if(docked)return;
    const start=btn.getBoundingClientRect();
    const width=Math.min(Math.max(btn.offsetWidth,start.width),Math.max(160,window.innerWidth-20));
    const height=Math.max(btn.offsetHeight,start.height);
    const targetTop=12;
    const targetLeft=Math.round((window.innerWidth-width)/2);

    holder.style.height=`${height}px`;
    holder.classList.add("active");
    if(btn.parentElement!==document.body)document.body.appendChild(btn);

    btn.classList.add("is-docked");
    btn.style.width=`${width}px`;
    btn.style.left=`${targetLeft}px`;
    btn.style.top=`${targetTop}px`;
    btn.style.position="fixed";

    const end=btn.getBoundingClientRect();
    const dx=(start.left-end.left).toFixed(1);
    const dy=(start.top-end.top).toFixed(1);
    btn.style.transition="none";
    btn.style.transform=`translate(${dx}px, ${dy}px)`;
    requestAnimationFrame(()=>{
      btn.style.transition="transform .65s cubic-bezier(.2,.8,.2,1), box-shadow .2s ease";
      btn.style.transform="translate(0px, 0px)";
    });
    docked=true;
  }

  function undock(){
    if(!docked)return;
    btn.classList.remove("is-docked");
    btn.style.width="";
    btn.style.left="";
    btn.style.top="";
    btn.style.position="";
    btn.style.transform="";
    btn.style.transition="";
    const head=document.querySelector(".head");
    if(head)head.insertBefore(btn,holder);
    holder.classList.remove("active");
    holder.style.height="";
    docked=false;
    triggerY=null;
  }

  function update(){
    ensureTrigger();
    if(triggerY===null)return;
    if(window.scrollY>triggerY)dock();
    else undock();
  }

  window.addEventListener("scroll",update,{passive:true});
  window.addEventListener("resize",()=>{ if(docked)undock(); update(); });
  update();
})();
</script>
</body>
</html>

