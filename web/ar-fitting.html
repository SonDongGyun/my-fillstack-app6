<!doctype html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>안경 AR 가상 피팅 | 눈건강 시력지킴이</title>
<meta name="description" content="카메라 얼굴 인식 기반 3D 안경 AR 가상 피팅" />
<link rel="icon" type="image/svg+xml" href="/static/favicon.svg" />
<link rel="apple-touch-icon" href="/static/davich_logo.png" />
<style>
:root{--b900:#0b3d91;--line:#cfe3ff;--ink:#112a4a;--muted:#45658d}
*{box-sizing:border-box}
body{margin:0;min-height:100vh;font-family:-apple-system,BlinkMacSystemFont,"SF Pro Display","Apple SD Gothic Neo","Noto Sans KR",sans-serif;color:var(--ink);background:radial-gradient(1100px 640px at 10% -10%,#fff 0%,#f3f9ff 45%,#e8f2ff 100%),linear-gradient(180deg,#f8fcff 0%,#eaf4ff 100%);padding:24px}
.app{width:min(1040px,100%);margin:0 auto;border:1px solid var(--line);border-radius:22px;background:#ffffffdb;box-shadow:0 20px 48px #79acee24;padding:20px}
.head{display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap;margin-bottom:14px}
.title{margin:0;color:var(--b900);font-size:1.3rem}
.sub{margin:6px 0 0;color:var(--muted);font-size:.92rem}
.ghost-btn,.primary-btn{border-radius:10px;padding:9px 12px;font-weight:700;cursor:pointer;text-decoration:none;display:inline-flex;align-items:center;justify-content:center}
.ghost-btn{border:1px solid #d2e5ff;color:#1d5eb4;background:#f9fcff}
.primary-btn{border:0;color:#fff;background:linear-gradient(120deg,#1459c2,#2e7be8)}
.layout{display:grid;gap:14px;grid-template-columns:1.2fr .8fr}
.viewer{position:relative;border:1px solid #cfe2ff;border-radius:14px;background:#000;overflow:hidden;aspect-ratio:4/3}
video,canvas{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;transform:scaleX(-1)}
.side{border:1px solid #d8e9ff;border-radius:14px;background:#fbfdff;padding:12px}
.side h2{margin:0 0 10px;color:#164f9f;font-size:1.03rem}
.ctrl{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px}
.select-wrap{margin:10px 0 12px}
.select-label{display:block;margin:0 0 6px;font-size:.84rem;color:#3b5f8c;font-weight:700}
.select{width:100%;border:1px solid #cfe2ff;border-radius:10px;background:#fff;padding:10px 11px;font-size:.92rem;color:#224061}
.tune-grid{display:grid;gap:8px;margin-top:6px}
.tune-row{display:grid;grid-template-columns:82px 1fr 52px;gap:8px;align-items:center}
.tune-name{font-size:.8rem;color:#355985;font-weight:700}
.tune-val{font-size:.78rem;color:#355985;text-align:right}
.tune-row input[type="range"]{width:100%}
.note{color:#325780;font-size:.88rem;line-height:1.6}
.status{margin-top:8px;font-size:.88rem;color:#45658d;min-height:1.2rem}
@media (max-width:920px){.layout{grid-template-columns:1fr} .viewer{aspect-ratio:3/4} body{padding:10px}.app{padding:12px}}
</style>
</head>
<body>
<main class="app">
  <section class="head">
    <div>
      <h1 class="title">안경 AR 가상 피팅</h1>
      <p class="sub">모델별 미세 보정을 실시간으로 조절해 정렬을 맞출 수 있습니다.</p>
    </div>
    <a class="ghost-btn" href="/?view=home">운동 시작하기</a>
  </section>

  <section class="layout">
    <div class="viewer">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="arCanvas"></canvas>
    </div>
    <aside class="side">
      <h2>피팅 컨트롤</h2>
      <div class="ctrl">
        <button id="startBtn" class="primary-btn" type="button">카메라 시작</button>
        <button id="stopBtn" class="ghost-btn" type="button">중지</button>
        <button id="recalibrateBtn" class="ghost-btn" type="button">정면 재보정</button>
      </div>
      <div class="ctrl">
        <button id="zoomOutBtn" class="ghost-btn" type="button">화면 축소</button>
        <button id="zoomResetBtn" class="ghost-btn" type="button">배율 1x</button>
        <button id="zoomInBtn" class="ghost-btn" type="button">화면 확대</button>
      </div>
      <div class="select-wrap">
        <label class="select-label" for="modelSelect">안경 모델 선택</label>
        <select id="modelSelect" class="select"></select>
      </div>
      <div class="note" id="pdInfo">AI PD: 측정 전</div>
      <div class="select-wrap" id="stylePanel">
        <label class="select-label">스타일 시뮬레이션</label>
        <div class="tune-grid">
          <div class="tune-row"><span class="tune-name">Frame</span><input id="frameColorInput" type="color" value="#111111"/><span id="frameColorVal" class="tune-val">#111111</span></div>
          <div class="tune-row"><span class="tune-name">Lens Tint</span><input id="lensTintRange" type="range" min="0" max="100" step="1"/><span id="lensTintVal" class="tune-val">32%</span></div>
          <div class="tune-row"><span class="tune-name">Gloss</span><input id="glossRange" type="range" min="0" max="100" step="1"/><span id="glossVal" class="tune-val">58%</span></div>
        </div>
      </div>
      <div class="select-wrap" id="tunePanel">
        <label class="select-label">모델 미세 보정</label>
        <div class="tune-grid">
          <div class="tune-row"><span class="tune-name">Yaw</span><input id="yawRange" type="range" min="-180" max="180" step="1"/><span id="yawVal" class="tune-val">0</span></div>
          <div class="tune-row"><span class="tune-name">Pitch</span><input id="pitchRange" type="range" min="-90" max="90" step="1"/><span id="pitchVal" class="tune-val">0</span></div>
          <div class="tune-row"><span class="tune-name">Roll</span><input id="rollRange" type="range" min="-180" max="180" step="1"/><span id="rollVal" class="tune-val">0</span></div>
          <div class="tune-row"><span class="tune-name">Offset Y</span><input id="offsetYRange" type="range" min="-0.30" max="0.30" step="0.005"/><span id="offsetYVal" class="tune-val">0</span></div>
          <div class="tune-row"><span class="tune-name">Offset Z</span><input id="offsetZRange" type="range" min="-0.30" max="0.30" step="0.005"/><span id="offsetZVal" class="tune-val">0</span></div>
          <div class="tune-row"><span class="tune-name">Scale</span><input id="scaleRange" type="range" min="0.40" max="2.20" step="0.01"/><span id="scaleVal" class="tune-val">1</span></div>
          
        </div>
        <div class="ctrl" style="margin-top:8px"><button id="tuneResetBtn" class="ghost-btn" type="button">현재 모델 보정 초기화</button></div>
      </div>
      <div class="note">A/B/C 각각 다른 보정값으로 저장됩니다(브라우저 로컬 저장).</div>
      <div id="status" class="status">대기 중</div>
    </aside>
  </section>
</main>

<script src="/static/js/modules/ar-pose-filter.js"></script>
<script>
(()=>{
  const video=document.getElementById("video");
  const canvas=document.getElementById("arCanvas");
  const startBtn=document.getElementById("startBtn");
  const stopBtn=document.getElementById("stopBtn");
  const recalibrateBtn=document.getElementById("recalibrateBtn");
  const zoomOutBtn=document.getElementById("zoomOutBtn");
  const zoomResetBtn=document.getElementById("zoomResetBtn");
  const zoomInBtn=document.getElementById("zoomInBtn");
  const modelSelect=document.getElementById("modelSelect");
  const tunePanel=document.getElementById("tunePanel");
  const tuneResetBtn=document.getElementById("tuneResetBtn");
  const status=document.getElementById("status");

  const yawRange=document.getElementById("yawRange");
  const pitchRange=document.getElementById("pitchRange");
  const rollRange=document.getElementById("rollRange");
  const offsetYRange=document.getElementById("offsetYRange");
  const offsetZRange=document.getElementById("offsetZRange");
  const scaleRange=document.getElementById("scaleRange");

  const yawVal=document.getElementById("yawVal");
  const pitchVal=document.getElementById("pitchVal");
  const rollVal=document.getElementById("rollVal");
  const offsetYVal=document.getElementById("offsetYVal");
  const offsetZVal=document.getElementById("offsetZVal");
  const scaleVal=document.getElementById("scaleVal");
  const pdInfo=document.getElementById("pdInfo");
  const frameColorInput=document.getElementById("frameColorInput");
  const frameColorVal=document.getElementById("frameColorVal");
  const lensTintRange=document.getElementById("lensTintRange");
  const lensTintVal=document.getElementById("lensTintVal");
  const glossRange=document.getElementById("glossRange");
  const glossVal=document.getElementById("glossVal");

  const TUNE_STORAGE_KEY="arModelTuneV2";
  const STYLE_STORAGE_KEY="arStyleV1";

  const MODEL_OPTIONS=[
    {label:"기본 프레임 (모델 없음)",path:"",yaw:0,pitch:0,roll:0,offsetY:0,offsetZ:0,scale:1},
    {label:"모델 A",path:"/static/models/model_a.glb",yaw:0,pitch:0,roll:0,offsetY:-0.05,offsetZ:0.018,scale:0.78},
    {label:"모델 B",path:"/static/models/model_b.glb",yaw:0,pitch:0,roll:0,offsetY:-0.06,offsetZ:0.03,scale:0.82},
    {label:"모델 C",path:"/static/models/model_c.glb",yaw:0,pitch:0,roll:0,offsetY:-0.06,offsetZ:0.03,scale:0.82}
  ];

  const LIB_SOURCES={
    three:["/static/vendor/three.min.js","https://cdn.jsdelivr.net/npm/three/build/three.min.js"],
    gltf:["/static/vendor/GLTFLoader.js","https://cdn.jsdelivr.net/npm/three/examples/js/loaders/GLTFLoader.js"],
    camera:["/static/vendor/camera_utils.js","https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"],
    facemesh:["/static/vendor/face_mesh.js","https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"]
  };

  const FIT={
    positionSmooth:0.20,
    rotationSmooth:0.16,
    scaleSmooth:0.20,
    positionDeadzone:0.0036,
    rotationDeadzoneDeg:1.8,
    scaleDeadzone:0.018,
    scaleMul:4.4,
    minScale:0.28,
    maxScale:2.4,
    yOffset:0,
    zOffset:0,
  };

  const modelTune={};
  MODEL_OPTIONS.forEach((m)=>{ if(m.path)modelTune[m.path]={}; });
  const styleState={frameColor:"#111111",lensTint:32,gloss:58};
  const pdState={samples:[],valueMm:0,ready:false};

  function deg(rad){ return rad*180/Math.PI; }
  function rad(degVal){ return degVal*Math.PI/180; }
  function f2(v){ return Number(v).toFixed(2); }
  function f3(v){ return Number(v).toFixed(3); }

  function setStatus(txt){ status.textContent=txt; }

  function loadTuneStorage(){
    try{
      const raw=localStorage.getItem(TUNE_STORAGE_KEY);
      if(!raw)return;
      const parsed=JSON.parse(raw);
      if(!parsed||typeof parsed!=="object")return;
      Object.keys(parsed).forEach((path)=>{
        if(modelTune[path])Object.assign(modelTune[path],parsed[path]);
      });
    }catch(_){ }
  }

  function saveTuneStorage(){
    try{ localStorage.setItem(TUNE_STORAGE_KEY,JSON.stringify(modelTune)); }catch(_){ }
  }

  function loadStyleStorage(){
    try{
      const raw=localStorage.getItem(STYLE_STORAGE_KEY);
      if(!raw)return;
      const parsed=JSON.parse(raw);
      if(!parsed||typeof parsed!=="object")return;
      if(typeof parsed.frameColor==="string")styleState.frameColor=parsed.frameColor;
      if(Number.isFinite(parsed.lensTint))styleState.lensTint=Math.max(0,Math.min(100,parsed.lensTint));
      if(Number.isFinite(parsed.gloss))styleState.gloss=Math.max(0,Math.min(100,parsed.gloss));
    }catch(_){ }
  }

  function saveStyleStorage(){
    try{ localStorage.setItem(STYLE_STORAGE_KEY,JSON.stringify(styleState)); }catch(_){ }
  }

  function getModelBase(path){
    return MODEL_OPTIONS.find((m)=>m.path===path)||MODEL_OPTIONS[0];
  }

  function getEffectiveCfg(path){
    const base=getModelBase(path);
    if(!path)return {...base};
    return {...base,...(modelTune[path]||{})};
  }

  function applyViewZoom(){
    const t=`scaleX(-1) scale(${viewZoom.toFixed(2)})`;
    video.style.transform=t;
    canvas.style.transform=t;
  }

  function loadScript(src){
    return new Promise((resolve,reject)=>{
      const s=document.createElement("script");
      s.src=src;
      s.async=true;
      s.onload=()=>resolve(src);
      s.onerror=()=>reject(new Error(`load failed: ${src}`));
      document.head.appendChild(s);
    });
  }

  async function loadFromAny(urls){
    let lastErr=null;
    for(const url of urls){
      try{ await loadScript(url); return; }
      catch(err){ lastErr=err; }
    }
    throw lastErr||new Error("script load failed");
  }

  async function ensureDeps(){
    if(typeof window.THREE==="undefined"){
      setStatus("AR 엔진 로드 중...");
      await loadFromAny(LIB_SOURCES.three);
    }
    if(typeof window.THREE==="undefined")throw new Error("THREE 로드 실패");

    if(typeof window.Camera==="undefined"){
      setStatus("카메라 모듈 로드 중...");
      await loadFromAny(LIB_SOURCES.camera);
    }
    if(typeof window.FaceMesh==="undefined"){
      setStatus("얼굴 인식 모듈 로드 중...");
      await loadFromAny(LIB_SOURCES.facemesh);
    }

    if(typeof window.THREE.GLTFLoader==="undefined"){
      try{ await loadFromAny(LIB_SOURCES.gltf); }catch(_){ }
    }
  }

  let renderer=null;
  let scene=null;
  let cam3d=null;
  let mpCam=null;
  let faceMesh=null;
  let pipelineReady=false;
  let glasses=null;
  let fallback=null;
  let selectedModelCfg=getEffectiveCfg(MODEL_OPTIONS[1].path);
  let selectedModelPath=selectedModelCfg.path;
  let modelLoadSeq=0;
  let modelRotQuat=null;
  let modelOffsetY=0;
  let modelOffsetZ=0;
  let modelScaleMul=1;
  let isModelSwitching=false;
  let viewZoom=1;

  const fitState={initialized:false,position:null,quaternion:null,scale:1,targetQuaternion:null};
  const analysisState={
    active:false,
    ready:false,
    needed:36,
    count:0,
    samples:null,
    base:null,
  };
  const poseFilter=(typeof window!=="undefined"&&window.ArPoseFilter&&window.ArPoseFilter.create)
    ? window.ArPoseFilter.create({
      posDeadzone:0.0032,
      rotDeadzoneDeg:1.7,
      scaleDeadzone:0.013,
      alphaMin:0.045,
      alphaMax:0.16,
      motionGain:0.15,
      maxPosPerSec:0.92,
      maxRotDegPerSec:46,
      maxScalePerSec:0.48,
    })
    : null;

  
  function medianLocal(arr){
    if(!arr||arr.length===0)return 0;
    const sorted=[...arr].sort((a,b)=>a-b);
    const mid=Math.floor(sorted.length*0.5);
    return sorted.length%2?sorted[mid]:(sorted[mid-1]+sorted[mid])*0.5;
  }

  function estimatePdMm(points){
    const pr=points[468],pl=points[473];
    if(!pr||!pl)return null;
    const pdNorm=Math.hypot(pl.x-pr.x,pl.y-pr.y);
    const d=(a,b)=>Math.hypot((points[a]?.x||0)-(points[b]?.x||0),(points[a]?.y||0)-(points[b]?.y||0));
    const irisRight=(d(469,471)+d(470,472))*0.5;
    const irisLeft=(d(474,476)+d(475,477))*0.5;
    const iris=(irisRight>0&&irisLeft>0)?(irisRight+irisLeft)*0.5:(irisRight||irisLeft);
    if(!iris||iris<1e-5)return null;
    const pdMm=(pdNorm/iris)*11.7;
    return THREE.MathUtils.clamp(pdMm,50,78);
  }

  function pushPdSample(mm){
    if(!Number.isFinite(mm))return;
    pdState.samples.push(mm);
    if(pdState.samples.length>45)pdState.samples.shift();
    if(pdState.samples.length<8)return;
    pdState.valueMm=medianLocal(pdState.samples);
    pdState.ready=true;
    pdInfo.textContent=`AI PD: ${pdState.valueMm.toFixed(1)} mm`;
  }

  function ensureMat(node){
    if(!node.material)return [];
    const mats=Array.isArray(node.material)?node.material:[node.material];
    return mats.map((m)=>{
      if(!m||typeof m.clone!=="function")return m;
      if(m.userData&&m.userData.__arStyled)return m;
      const cloned=m.clone();
      cloned.userData={...(cloned.userData||{}),__arStyled:true};
      return cloned;
    });
  }

  function applyStyleToObject(obj){
    if(!obj)return;
    obj.traverse((node)=>{
      if(!node.isMesh)return;
      const mats=ensureMat(node);
      if(Array.isArray(node.material))node.material=mats;
      else node.material=mats[0];
      mats.forEach((m)=>{
        if(!m||!m.color)return;
        const key=`${(node.name||"")} ${(m.name||"")}`.toLowerCase();
        const isLens=/lens|glass|lense|렌즈/.test(key);
        if(isLens){
          m.transparent=true;
          m.opacity=THREE.MathUtils.clamp(0.92-(styleState.lensTint/100)*0.72,0.20,0.95);
          m.color.setRGB(0.62,0.68,0.74);
          m.metalness=0.0;
          m.roughness=THREE.MathUtils.clamp(0.22-(styleState.gloss/100)*0.15,0.03,0.25);
          m.envMapIntensity=0.9+(styleState.gloss/100)*0.9;
        }else{
          m.color.set(styleState.frameColor);
          m.metalness=0.25+(styleState.gloss/100)*0.55;
          m.roughness=0.55-(styleState.gloss/100)*0.35;
          m.envMapIntensity=0.6+(styleState.gloss/100)*0.8;
        }
        m.needsUpdate=true;
      });
    });
  }

  function applyStyleTargets(){
    if(glasses)applyStyleToObject(glasses);
    if(fallback)applyStyleToObject(fallback);
  }

  function syncStyleUI(){
    frameColorInput.value=styleState.frameColor;
    frameColorVal.textContent=styleState.frameColor.toUpperCase();
    lensTintRange.value=String(styleState.lensTint);
    lensTintVal.textContent=`${styleState.lensTint}%`;
    glossRange.value=String(styleState.gloss);
    glossVal.textContent=`${styleState.gloss}%`;
  }

  function setupStyleControls(){
    const onStyle=()=>{
      styleState.frameColor=frameColorInput.value;
      styleState.lensTint=Number(lensTintRange.value);
      styleState.gloss=Number(glossRange.value);
      syncStyleUI();
      applyStyleTargets();
      saveStyleStorage();
      setStatus("스타일 변경 적용됨");
    };
    frameColorInput.addEventListener("input",onStyle);
    lensTintRange.addEventListener("input",onStyle);
    glossRange.addEventListener("input",onStyle);
  }

  function initRenderer(){
    renderer=new THREE.WebGLRenderer({canvas,alpha:true,antialias:true});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio||1,2));
    if("outputColorSpace" in renderer&&THREE.SRGBColorSpace)renderer.outputColorSpace=THREE.SRGBColorSpace;
    if("toneMapping" in renderer)renderer.toneMapping=THREE.ACESFilmicToneMapping;
    if("toneMappingExposure" in renderer)renderer.toneMappingExposure=1.06;
    scene=new THREE.Scene();
    cam3d=new THREE.PerspectiveCamera(45,1,0.1,100);
    cam3d.position.set(0,0,3.2);
    scene.add(new THREE.AmbientLight(0xffffff,1.1));
    scene.add(new THREE.HemisphereLight(0xdde8ff,0x2f2f36,0.55));
    const keyLight=new THREE.DirectionalLight(0xffffff,1.0);
    keyLight.position.set(0,1.8,2.3);
    scene.add(keyLight);

    const resize=()=>{
      const w=canvas.clientWidth||640;
      const h=canvas.clientHeight||480;
      renderer.setSize(w,h,false);
      cam3d.aspect=w/h;
      cam3d.updateProjectionMatrix();
    };
    window.addEventListener("resize",resize);
    resize();

    fitState.position=new THREE.Vector3();
    fitState.quaternion=new THREE.Quaternion();
    fitState.targetQuaternion=new THREE.Quaternion();
    modelRotQuat=new THREE.Quaternion();

    applyViewZoom();
  }

  function createFallbackGlasses(){
    const group=new THREE.Group();
    const mat=new THREE.MeshStandardMaterial({color:0x2b3b54,roughness:0.35,metalness:0.2});
    const lensL=new THREE.Mesh(new THREE.TorusGeometry(0.24,0.015,14,40),mat);
    const lensR=lensL.clone();
    lensL.position.x=-0.30;
    lensR.position.x=0.30;
    const bridge=new THREE.Mesh(new THREE.BoxGeometry(0.16,0.02,0.02),mat);
    const templeL=new THREE.Mesh(new THREE.BoxGeometry(0.02,0.02,0.42),mat);
    const templeR=templeL.clone();
    templeL.position.set(-0.55,0,-0.18);
    templeR.position.set(0.55,0,-0.18);
    group.add(lensL,lensR,bridge,templeL,templeR);
    group.visible=false;
    scene.add(group);
    applyStyleToObject(group);
    return group;
  }

  function disposeObject3D(obj){
    if(!obj)return;
    obj.traverse((node)=>{
      if(node.geometry&&typeof node.geometry.dispose==="function")node.geometry.dispose();
      if(node.material){
        const mats=Array.isArray(node.material)?node.material:[node.material];
        mats.forEach((m)=>{
          if(!m)return;
          Object.keys(m).forEach((k)=>{
            const v=m[k];
            if(v&&typeof v.dispose==="function"&&v.isTexture)v.dispose();
          });
          if(typeof m.dispose==="function")m.dispose();
        });
      }
    });
  }

  function clearGlasses(){
    if(glasses){
      scene.remove(glasses);
      disposeObject3D(glasses);
      glasses=null;
    }
  }

  function safeBoxSize(obj){
    const box=new THREE.Box3().setFromObject(obj);
    const size=new THREE.Vector3();
    box.getSize(size);
    return {box,size};
  }

  function normalizeLoadedGlasses(root){
    if(!root)return root;

    const yawCandidates=[0,Math.PI*0.5,-Math.PI*0.5,Math.PI];
    let bestYaw=0;
    let bestScore=-Infinity;

    yawCandidates.forEach((yaw)=>{
      root.rotation.set(0,yaw,0);
      root.updateMatrixWorld(true);
      const {size}=safeBoxSize(root);
      if(size.x<=1e-6||size.y<=1e-6||size.z<=1e-6)return;
      const width=Math.max(size.x,size.z);
      const depth=Math.min(size.x,size.z);
      const score=width-(depth*0.35);
      if(score>bestScore){
        bestScore=score;
        bestYaw=yaw;
      }
    });

    root.rotation.set(0,bestYaw,0);
    root.updateMatrixWorld(true);

    let {box,size}=safeBoxSize(root);
    const width=Math.max(size.x,size.z);
    if(width>1e-6){
      const targetWidth=1.08;
      const normScale=targetWidth/width;
      root.scale.multiplyScalar(normScale);
      root.updateMatrixWorld(true);
      ({box,size}=safeBoxSize(root));
    }

    const center=new THREE.Vector3();
    box.getCenter(center);
    const bridgePivot=new THREE.Vector3(
      center.x,
      box.min.y+(size.y*0.53),
      center.z
    );
    root.position.sub(bridgePivot);
    root.updateMatrixWorld(true);
    return root;
  }

  function ndcToWorld(nx,ny){
    const halfH=Math.tan(THREE.MathUtils.degToRad(cam3d.fov*0.5))*cam3d.position.z;
    const halfW=halfH*cam3d.aspect;
    return new THREE.Vector3((nx-0.5)*2*halfW,-(ny-0.5)*2*halfH,0);
  }

  function toSceneVec(p){ return new THREE.Vector3(p.x,-p.y,-p.z); }

  function getPose(points){
    const left=points[234],right=points[454],nose=points[6],bridge=points[168],forehead=points[10],chin=points[152];
    const eyeL=points[33],eyeR=points[263],earL=points[127],earR=points[356];
    if(!left||!right||!nose||!bridge||!forehead||!chin||!eyeL||!eyeR)return null;

    const pupilR=points[468],pupilL=points[473];
    const rollL=pupilL||eyeL;
    const rollR=pupilR||eyeR;
    const rightVec=toSceneVec({x:rollR.x-rollL.x,y:rollR.y-rollL.y,z:rollR.z-rollL.z});
    const upHint=toSceneVec({x:bridge.x-chin.x,y:bridge.y-chin.y,z:bridge.z-chin.z});
    if(rightVec.lengthSq()<1e-8||upHint.lengthSq()<1e-8)return null;

    const xAxis=rightVec.normalize();
    let zAxis=new THREE.Vector3().crossVectors(xAxis,upHint).normalize();
    if(zAxis.lengthSq()<1e-8)return null;

    const forwardHint=toSceneVec({x:nose.x-bridge.x,y:nose.y-bridge.y,z:nose.z-bridge.z}).normalize();
    if(forwardHint.lengthSq()>1e-8&&zAxis.dot(forwardHint)<0)zAxis.multiplyScalar(-1);

    let yAxis=new THREE.Vector3().crossVectors(zAxis,xAxis).normalize();
    if(yAxis.dot(upHint)<0){
      yAxis.multiplyScalar(-1);
      zAxis.multiplyScalar(-1);
    }
    const basis=new THREE.Matrix4().makeBasis(xAxis,yAxis,zAxis);
    const quat=new THREE.Quaternion().setFromRotationMatrix(basis);
    const euler=new THREE.Euler().setFromQuaternion(quat,"YXZ");

    const eyeCenterX=(eyeL.x+eyeR.x)*0.5;
    const eyeCenterY=(eyeL.y+eyeR.y)*0.5;
    const pupilMidX=(pupilR&&pupilL)?(pupilR.x+pupilL.x)*0.5:eyeCenterX;
    const pupilMidY=(pupilR&&pupilL)?(pupilR.y+pupilL.y)*0.5:eyeCenterY;

    let anchorX=bridge.x*0.56+pupilMidX*0.40+nose.x*0.04;
    let anchorY=bridge.y*0.46+pupilMidY*0.48+nose.y*0.06;
    if(analysisState.ready&&analysisState.base){
      const eTmp=new THREE.Euler().setFromQuaternion(quat,"YXZ");
      const frontal=THREE.MathUtils.clamp(
        1-((Math.abs(eTmp.x)/THREE.MathUtils.degToRad(20))+(Math.abs(eTmp.y)/THREE.MathUtils.degToRad(26)))*0.5,
        0,
        1
      );
      anchorX=anchorX*(1-(0.14*frontal))+analysisState.base.anchorX*(0.14*frontal);
      anchorY=anchorY*(1-(0.12*frontal))+analysisState.base.anchorY*(0.12*frontal);
    }

    const pos=ndcToWorld(anchorX,anchorY);
    pos.y+=FIT.yOffset;
    pos.z+=FIT.zOffset;

    const eyeDist2d=Math.hypot(eyeR.x-eyeL.x,eyeR.y-eyeL.y);
    const pdNorm=(pupilR&&pupilL)?Math.hypot(pupilL.x-pupilR.x,pupilL.y-pupilR.y):eyeDist2d;
    const faceWidth2d=Math.hypot(right.x-left.x,right.y-left.y);
    const earSpan2d=(earL&&earR)?Math.hypot(earR.x-earL.x,earR.y-earL.y):faceWidth2d;
    const noseBridgeDepth=Math.abs((nose.z||0)-(bridge.z||0));
    const earDepth=(earL&&earR)?Math.abs((earR.z||0)-(earL.z||0)):noseBridgeDepth;
    const scaleSeed=(pdNorm*0.64)+(faceWidth2d*0.30)+(earSpan2d*0.06);
    const scale=THREE.MathUtils.clamp(scaleSeed*FIT.scaleMul,FIT.minScale,FIT.maxScale);

    const eyeRoll=Math.atan2(rollR.y-rollL.y,rollR.x-rollL.x);

    return {position:pos,quaternion:quat,scale,anchorX,anchorY,eyeDist2d,pdNorm,faceWidth2d,earSpan2d,noseBridgeDepth,earDepth,pitch:euler.x,yaw:euler.y,roll:euler.z,eyeRoll};
  }

  function isFrontalCandidate(pose){
    if(!pose)return false;
    const pitchAbs=Math.abs(deg(pose.pitch||0));
    const yawAbs=Math.abs(deg(pose.yaw||0));
    return pitchAbs<=13&&yawAbs<=16;
  }

  function syncModelTransform(cfg){
    if(modelRotQuat)modelRotQuat.setFromEuler(new THREE.Euler(cfg.pitch||0,cfg.yaw||0,cfg.roll||0));
    modelOffsetY=cfg.offsetY||0;
    modelOffsetZ=cfg.offsetZ||0;
    modelScaleMul=cfg.scale||1;
    fitState.initialized=false;
    if(poseFilter)poseFilter.reset();
  }

  function median(arr){
    if(!arr||arr.length===0)return 0;
    const sorted=[...arr].sort((a,b)=>a-b);
    const mid=Math.floor(sorted.length*0.5);
    return sorted.length%2?sorted[mid]:(sorted[mid-1]+sorted[mid])*0.5;
  }

  function resetFaceAnalysis(){
    analysisState.count=0;
    analysisState.samples={
      anchorX:[],anchorY:[],eyeDist:[],pdNorm:[],faceWidth:[],earSpan:[],noseBridgeDepth:[],earDepth:[],roll:[],eyeRoll:[],pitch:[],yaw:[],scale:[]
    };
  }

  function startFaceAnalysis(){
    analysisState.active=true;
    analysisState.ready=false;
    analysisState.base=null;
    resetFaceAnalysis();
    fitState.initialized=false;
    if(poseFilter)poseFilter.reset();
    hideModel();
    setStatus("얼굴 분석 중... 정면을 1초 유지해 주세요");
  }

  function pushFaceSample(pose){
    if(!analysisState.active||!analysisState.samples)return;
    analysisState.samples.anchorX.push(pose.anchorX);
    analysisState.samples.anchorY.push(pose.anchorY);
    analysisState.samples.eyeDist.push(pose.eyeDist2d);
    analysisState.samples.pdNorm.push(pose.pdNorm);
    analysisState.samples.faceWidth.push(pose.faceWidth2d);
    analysisState.samples.earSpan.push(pose.earSpan2d);
    analysisState.samples.noseBridgeDepth.push(pose.noseBridgeDepth);
    analysisState.samples.earDepth.push(pose.earDepth);
    analysisState.samples.roll.push(pose.roll);
    analysisState.samples.eyeRoll.push(pose.eyeRoll);
    analysisState.samples.pitch.push(pose.pitch);
    analysisState.samples.yaw.push(pose.yaw);
    analysisState.samples.scale.push(pose.scale);
    analysisState.count++;

    if(analysisState.count>=analysisState.needed){
      analysisState.base={
        anchorX:median(analysisState.samples.anchorX),
        anchorY:median(analysisState.samples.anchorY),
        eyeDist:median(analysisState.samples.eyeDist),
        pdNorm:median(analysisState.samples.pdNorm),
        faceWidth:median(analysisState.samples.faceWidth),
        earSpan:median(analysisState.samples.earSpan),
        noseBridgeDepth:median(analysisState.samples.noseBridgeDepth),
        earDepth:median(analysisState.samples.earDepth),
        roll:median(analysisState.samples.roll),
        eyeRoll:median(analysisState.samples.eyeRoll),
        pitch:median(analysisState.samples.pitch),
        yaw:median(analysisState.samples.yaw),
        scale:median(analysisState.samples.scale),
      };
      analysisState.active=false;
      analysisState.ready=true;
      fitState.initialized=false;
      setStatus("얼굴 분석 완료: 피팅 시작");
    }else if((analysisState.count%8)===0){
      const p=Math.min(100,Math.round((analysisState.count/analysisState.needed)*100));
      setStatus(`얼굴 분석 중... ${p}%`);
    }
  }

  function applyModel(pose){
    let target=null;
    if(glasses)target=glasses;
    else if(!selectedModelPath&&!isModelSwitching)target=fallback;
    if(!target)return;

    if(!analysisState.ready){
      if(!analysisState.active)startFaceAnalysis();
      if(!isFrontalCandidate(pose)){
        setStatus("얼굴 분석 중... 정면 권장");
      }
      pushFaceSample(pose);
    }

    let correctedQuat=pose.quaternion;
    let targetScale=pose.scale;

    if(analysisState.base){
      const e=new THREE.Euler().setFromQuaternion(pose.quaternion,"YXZ");
      const pitchAbs=Math.abs(e.x);
      const yawAbs=Math.abs(e.y);
      const frontalFactor=THREE.MathUtils.clamp(1-((pitchAbs/THREE.MathUtils.degToRad(16))+(yawAbs/THREE.MathUtils.degToRad(22)))*0.5,0.04,1);
      const rollGain=0.018+(frontalFactor*0.055);
      const rollDelta=(analysisState.base.eyeRoll-pose.eyeRoll)*rollGain;
      const rollClamp=THREE.MathUtils.degToRad(3.5);
      const rollBase=analysisState.base.roll||0;
      const dynamicRoll=THREE.MathUtils.clamp(rollBase+rollDelta,rollBase-rollClamp,rollBase+rollClamp);
      const frontalLevelLock=THREE.MathUtils.clamp((frontalFactor-0.62)/0.38,0,1);
      e.z=THREE.MathUtils.lerp(dynamicRoll,rollBase,frontalLevelLock*0.88);
      correctedQuat=new THREE.Quaternion().setFromEuler(e);

      const pdBase=Math.max(analysisState.base.pdNorm||analysisState.base.eyeDist||1e-6,1e-6);
      const pdNow=Math.max(pose.pdNorm||pose.eyeDist2d||1e-6,1e-6);
      const pdRatio=THREE.MathUtils.clamp(pdNow/pdBase,0.84,1.22);
      const baseSpan=Math.max(analysisState.base.earSpan||analysisState.base.faceWidth||1e-6,1e-6);
      const nowSpan=Math.max(pose.earSpan2d||pose.faceWidth2d||1e-6,1e-6);
      const widthRatio=THREE.MathUtils.clamp(nowSpan/baseSpan,0.84,1.22);
      const baseScale=Math.max(analysisState.base.scale||pose.scale||FIT.minScale,FIT.minScale);
      const depthMix=(pdRatio*0.55)+(widthRatio*0.45);
      const blendedDepth=THREE.MathUtils.lerp(1,depthMix,0.66);
      targetScale=THREE.MathUtils.clamp(baseScale*blendedDepth,FIT.minScale,FIT.maxScale);
    }

    const nowMs=(typeof performance!=="undefined"&&performance.now)?performance.now():Date.now();
    const baseDepth=((analysisState.base?.noseBridgeDepth||pose.noseBridgeDepth||0)*0.65)+((analysisState.base?.earDepth||pose.earDepth||0)*0.35);
    const nowDepth=((pose.noseBridgeDepth||0)*0.65)+((pose.earDepth||0)*0.35);
    const depthDelta=THREE.MathUtils.clamp((nowDepth-baseDepth)*1.6,-0.06,0.06);

    const rawPose={
      px:pose.position.x,
      py:pose.position.y,
      pz:pose.position.z+depthDelta,
      qx:correctedQuat.x,
      qy:correctedQuat.y,
      qz:correctedQuat.z,
      qw:correctedQuat.w,
      scale:targetScale,
    };
    const filtered=poseFilter?poseFilter.update(rawPose,nowMs):rawPose;

    fitState.position.set(filtered.px,filtered.py,filtered.pz);
    fitState.quaternion.set(filtered.qx,filtered.qy,filtered.qz,filtered.qw);
    fitState.scale=filtered.scale;
    fitState.initialized=true;

    target.visible=true;
    target.position.copy(fitState.position);
    if(target===glasses){
      target.position.y+=modelOffsetY;
      target.position.z+=modelOffsetZ;
    }
    target.quaternion.copy(fitState.quaternion);
    if(target===glasses&&modelRotQuat)target.quaternion.premultiply(modelRotQuat);
    target.scale.setScalar(target===glasses?fitState.scale*modelScaleMul:fitState.scale);
  }

  function hideModel(){
    if(glasses)glasses.visible=false;
    if(fallback)fallback.visible=false;
  }

  function ensurePipeline(){
    if(pipelineReady)return;
    faceMesh=new FaceMesh({locateFile:(f)=>`/static/vendor/${f}`});
    faceMesh.setOptions({maxNumFaces:1,refineLandmarks:true,minDetectionConfidence:0.55,minTrackingConfidence:0.55});
    faceMesh.onResults((results)=>{
      const pts=results.multiFaceLandmarks&&results.multiFaceLandmarks[0];
      if(pts){
        const pd=estimatePdMm(pts);
        if(pd!==null)pushPdSample(pd);
        const pose=getPose(pts);
        if(pose)applyModel(pose); else hideModel();
      }else hideModel();
      renderer.render(scene,cam3d);
    });
    pipelineReady=true;
  }

  async function loadGlasses(path,cfg=selectedModelCfg){
    const seq=++modelLoadSeq;
    isModelSwitching=true;
    clearGlasses();
    if(fallback)fallback.visible=false;
    if(renderer&&scene&&cam3d)renderer.render(scene,cam3d);

    if(!path){
      if(modelRotQuat)modelRotQuat.identity();
      modelOffsetY=0; modelOffsetZ=0; modelScaleMul=1;
      setStatus("기본 프레임 모드");
      isModelSwitching=false;
      return;
    }

    if(!THREE.GLTFLoader){
      setStatus("GLB 로더 없음: 기본 프레임 사용");
      isModelSwitching=false;
      return;
    }

    await new Promise((resolve)=>{
      const loader=new THREE.GLTFLoader();
      loader.load(path,(gltf)=>{
        if(seq!==modelLoadSeq){ disposeObject3D(gltf.scene); resolve(); return; }
        clearGlasses();
        glasses=gltf.scene;
        normalizeLoadedGlasses(glasses);
        glasses.visible=false;
        glasses.scale.setScalar(0.95);
        scene.add(glasses);
        applyStyleToObject(glasses);
        if(fallback)fallback.visible=false;
        syncModelTransform(cfg);
        setStatus(`모델 선택 완료: ${path.split("/").pop()}`);
        isModelSwitching=false;
        resolve();
      },undefined,()=>{
        if(seq===modelLoadSeq)setStatus("선택 모델 로드 실패: 기본 프레임 사용");
        if(seq===modelLoadSeq)isModelSwitching=false;
        resolve();
      });
    });
  }

  function setTuneEnabled(enabled){
    tunePanel.style.opacity=enabled?"1":"0.5";
    [yawRange,pitchRange,rollRange,offsetYRange,offsetZRange,scaleRange,tuneResetBtn].forEach((el)=>el.disabled=!enabled);
  }

  function syncTuneUI(cfg){
    yawRange.value=String(Math.round(deg(cfg.yaw||0)));
    pitchRange.value=String(Math.round(deg(cfg.pitch||0)));
    rollRange.value=String(Math.round(deg(cfg.roll||0)));
    offsetYRange.value=String(cfg.offsetY||0);
    offsetZRange.value=String(cfg.offsetZ||0);
    scaleRange.value=String(cfg.scale||1);

    yawVal.textContent=String(Math.round(deg(cfg.yaw||0)));
    pitchVal.textContent=String(Math.round(deg(cfg.pitch||0)));
    rollVal.textContent=String(Math.round(deg(cfg.roll||0)));
    offsetYVal.textContent=f3(cfg.offsetY||0);
    offsetZVal.textContent=f3(cfg.offsetZ||0);
    scaleVal.textContent=f2(cfg.scale||1);
  }

  function setupTuneControls(){
    const onChange=()=>{
      if(!selectedModelPath)return;

      const tune={
        yaw:rad(Number(yawRange.value)),
        pitch:rad(Number(pitchRange.value)),
        roll:rad(Number(rollRange.value)),
        offsetY:Number(offsetYRange.value),
        offsetZ:Number(offsetZRange.value),
        scale:Number(scaleRange.value),
      };
      modelTune[selectedModelPath]={...modelTune[selectedModelPath],...tune};
      selectedModelCfg=getEffectiveCfg(selectedModelPath);
      syncModelTransform(selectedModelCfg);
      saveTuneStorage();

      yawVal.textContent=String(Math.round(Number(yawRange.value)));
      pitchVal.textContent=String(Math.round(Number(pitchRange.value)));
      rollVal.textContent=String(Math.round(Number(rollRange.value)));
      offsetYVal.textContent=f3(Number(offsetYRange.value));
      offsetZVal.textContent=f3(Number(offsetZRange.value));
      scaleVal.textContent=f2(Number(scaleRange.value));
      setStatus("미세 보정값 적용됨");
    };

    [yawRange,pitchRange,rollRange,offsetYRange,offsetZRange,scaleRange].forEach((el)=>{
      el.addEventListener("input",onChange);
      el.addEventListener("change",onChange);
    });

    tuneResetBtn.addEventListener("click",()=>{
      if(!selectedModelPath)return;
      modelTune[selectedModelPath]={};
      selectedModelCfg=getEffectiveCfg(selectedModelPath);
      syncTuneUI(selectedModelCfg);
      syncModelTransform(selectedModelCfg);
      saveTuneStorage();
      setStatus("현재 모델 보정값 초기화 완료");
    });
  }

  function setupModelSelect(){
    modelSelect.innerHTML="";
    MODEL_OPTIONS.forEach((opt)=>{
      const el=document.createElement("option");
      el.value=opt.path;
      el.textContent=opt.label;
      modelSelect.appendChild(el);
    });
    modelSelect.value=selectedModelPath;
    modelSelect.addEventListener("change",async()=>{
      selectedModelPath=modelSelect.value;
      selectedModelCfg=getEffectiveCfg(selectedModelPath);
      setTuneEnabled(!!selectedModelPath);
      syncTuneUI(selectedModelCfg);
      await loadGlasses(selectedModelPath,selectedModelCfg);
    });
  }

  async function start(){
    try{
      setStatus("카메라 시작 중...");
      fitState.initialized=false;
      startFaceAnalysis();

      if(!pipelineReady)ensurePipeline();
      if(typeof Camera==="undefined")throw new Error("Camera unavailable");
      if(!mpCam){
        mpCam=new Camera(video,{onFrame:async()=>{ await faceMesh.send({image:video}); },width:960,height:720});
      }
      await mpCam.start();
      startBtn.disabled=true;
      setStatus("실행 중");
    }catch(err){
      const msg=String(err?.message||"");
      if(/secure|https/i.test(msg))setStatus("카메라 시작 실패: HTTPS 환경에서 실행해 주세요");
      else if(/denied|notallowed|permission/i.test(msg.toLowerCase()))setStatus("카메라 권한이 거부되었습니다. 브라우저 설정에서 허용해 주세요");
      else setStatus("카메라 시작 실패: 라이브러리/권한 확인 필요");
      console.error(err);
    }
  }

  function stop(){
    try{
      if(video&&video.srcObject){
        video.srcObject.getTracks().forEach((t)=>t.stop());
        video.srcObject=null;
      }
      hideModel();
      fitState.initialized=false;
      if(poseFilter)poseFilter.reset();
      if(renderer&&scene&&cam3d)renderer.render(scene,cam3d);
      startBtn.disabled=false;
      setStatus("중지됨");
    }catch(_){ }
  }

  function setupZoomControls(){
    zoomInBtn.addEventListener("click",()=>{ viewZoom=Math.min(1.8,viewZoom+0.1); applyViewZoom(); setStatus(`화면 배율: ${viewZoom.toFixed(1)}x`); });
    zoomOutBtn.addEventListener("click",()=>{ viewZoom=Math.max(0.8,viewZoom-0.1); applyViewZoom(); setStatus(`화면 배율: ${viewZoom.toFixed(1)}x`); });
    zoomResetBtn.addEventListener("click",()=>{ viewZoom=1; applyViewZoom(); setStatus("화면 배율: 1.0x"); });
  }

  async function boot(){
    try{
      loadTuneStorage();
      loadStyleStorage();
      await ensureDeps();
      initRenderer();
      fallback=createFallbackGlasses();
      setupModelSelect();
      setupTuneControls();
      setupStyleControls();
      setupZoomControls();
      syncStyleUI();

      selectedModelCfg=getEffectiveCfg(selectedModelPath);
      setTuneEnabled(!!selectedModelPath);
      syncTuneUI(selectedModelCfg);

      await loadGlasses(selectedModelPath,selectedModelCfg);
      setStatus("대기 중");
    }catch(err){
      console.error(err);
      setStatus("초기화 실패: 네트워크/스크립트 로드 확인 필요");
    }
  }

  startBtn.addEventListener("click",start);
  stopBtn.addEventListener("click",stop);
  recalibrateBtn.addEventListener("click",()=>{
    startFaceAnalysis();
  });
  window.addEventListener("error",(evt)=>{
    const msg=String(evt?.message||"");
    if(msg)setStatus(`오류: ${msg}`);
  });

  boot();
})();
</script>
</body>
</html>
